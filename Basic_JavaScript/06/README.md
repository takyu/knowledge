## Constructor 

Constructor Function as a template for creating new objects.  
Use "new" operator to call the constructor function.  
Creating an object using the new operator is called "instantiation", an object created by the new operator is called an "instance".  
To clearly distinguish constructor functions from general functions, the first letter of constructor functions is capitalize.
```JS
const obj = new Constructor();
```

## prototype

Prototype is special properties present in the object.  
It is used in conjunction with the constructor function.  
When instantiated, the reference to "prototype" is copied to "\_\_proto\_\_".  
This is a reasonable mechanism to prevent the same method from being copied over and over again, resulting in a large memory footprint.

## New Operator

Operator used to create an instance from a constructor function.  

- If the return value of the constructor function

	- is an object  
	The object returned by the constructor function is returned to the caller as a new instance object.

	- is **not** an object  
	Copy the reference to "prototype" which is a property of the constructor function to "\_\_proto\_\_" and return the "this" used in the constructor function to the caller

## Object.create()

Method to create a new object using an existing object as a prototype for the newly created object.  
<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create>
```JS
Object.create(proto, [propertiesObject])
```

## instanceof

Check from which constructor the object was created.  
Since each constructor has a different method, "instanceof" is used for conditional branching.

## Function() Constructor

Method to create a new function object.  
<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/Function>  
Scope of function constructor is **global scope**.  
Note that function declarations and function constructors are different things, and that the first letter of "Function" in function constructors is capitalized.
```JS
new Function([arg1, ..., argN, functionBody);
```

## Prototype Chain

Prototype Chain is multiply formed prototype.  
In other words, "\_\_proto\_\_" is in a multi-level.  
First, check if the method you are looking for exists in yourself, if not, then check if the it in the parent class "prototype", if not, finally check if  it in the parent class of "prototype", "Object".  
```JS
property → __proto__(prototype) → __proto__ in __proto__(Object)
```

## hasOwnProperty

hasOwnProperty is a method.( Object.prototype.hasOwnProperty() )  
<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty>  
Return a boolean value indicating whether or not the object itself **(not inherited)** has the specified property.
```JS
obj.hasOwnProperty(prop)
```

## in

Return a boolean value indicating whether or not the object itself **(including inherited)** has the specified property.
```JS
prop in object
```

## Inheritance

Inheriting another constructor function.
```JS
personObj.call(childObj, arg1, ..., argN);
```

## Prototype Inheritance

To be able to inherit the prototype of another constructor function and use its functionality.
```JS
childObj.prototype = Object.create(personObj.prototype)
```

## Class

Syntax sugar of Class in JavaScript is that constructor functions can be written in class notation.  
Even if you use the class notation, the instance that is created is an object.
```JS
class Class {

	// constructor
	constructor(arg1, arg2) {
		this.arg1 = arg1;
		this.arg2 = arg2;
	}

	//prototype
	fn() {
		// processing content
	}
}
```

## Class Inheritance

Inheriting properties and methods from other classes.
```JS
class ChildClass extends PersonClass{
	
	// constructor
	constructor(arg1, arg2, arg3) {

		// use constructor of person
		super(arg1, arg2);

		this.arg3 = arg3;
	}

	//prototype
	fn() {
		// processing content
	}
}
```

## Super

Keyword to call the inherited function.  

- When using a constructor, if you want to use super to initialize the parent constructor, write it first.  

- When you want to call a method of the parent class, it doesn't matter where you write it.  

Also, it is also possible to call it in an object literal.

## setPrototypeOf

setPrototypeOf is a method.( Object.setPrototypeOf() )  
<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf>  
Set the prototype of the specified object to another object or null.  
```JS
Object.setPrototypeOf(obj, prototype);
```

## built-in objects

Before the code is executed, objects automatically generated by the JavaScript engine.
```JS
String, Object, Number, Function, Math, Boolean, Date, Symbol, etc...
```

## Wrapper Object

An object including a primitive value.  
When a variable declared as a primitive type calls a method, it implicitly calls the method of the wrapper object.

## Symbol

Function introduced in ES6 that always returns a unique value to avoid duplicate properties.  
To generate a symbol is not required to "new" operator.  
Symbol can be used as keys for object properties.  
Symbols were introduced in ES6 for compatibility reasons, in other words, it wanted to be able to safely create methods of prototype on objects that don't affect existing programs.  
In general, extending the methods of a prototype is called "prototype pollution" and is not recommended.
```JS
// argument is name of symbol
const a = Symbol('Hi');

// add method of prototype in object
obj.prototype[a] = function() {

	// process
	return 'Hi ' + this;
}

const name = 'Tom'

// access
const res = name[a]; // Hi Tom
```

## Property and Descriptor

There are four properties of object which are called descriptors.  

- value

- configurable

- enumerable

- writable

Also, there are two options, "set" and "get", which are defined by"undefined".

## getOwnPropertyDescriptor

getOwnPropertyDescriptor is a method.( Object.getOwnPropertyDescriptor() )  
<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor>  
Return object that describes the configuration of a specific property of given object.  
```JS
Object.getOwnPropertyDescriptor(obj, prop)
```

## defineProperty

defineProperty is a method. ( Object.defineProperty() )  
<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty>  
Define new properties directly on an object or modifies existing properties of an object, and returns the object.
```JS
Object.defineProperty(obj, prop, descriptor)
```

## getter / setter

getter to get the value and setter to set the value.  
It is used in ES6 notation as follows.
```JS
class Class {
	constructor(arg1, arg2) {
		this._arg1 = arg1;
		this._arg2 = arg2;
	}

	// getter
	get arg1() {
		return this._arg1;
	}

	// setter
	set arg1(val) {
		this._arg1 = val;
	}
}

const instance = new Class('a', 'b');

// get arg1
const res = instance.arg1;

// set arg1
instance.arg1('c');
```

## static

Static {proerty / method} is to be able to call directly from the constructor without having to create an instance, In contrast, Instance {property / method} is to create an instance and calls it via the instance.  
Note that static properties are basically used for read-only purposes and 'this' cannot be used for static methods (since 'this' represents the instance itself).  
It is used in ES6 notation as follows.
```JS
class Class {

	// static property
	static staticProperty = 'static property';

	// static method
	static staticMethod() {
		return 'static method has been called.';
	}

}

// access static property
console.log(Class.staticProperty); // static property

// access static method
console.log(Class.staticMethod()); // static method has been called.
```

## chain method

Notation used when executing multiple methods on a single instance.  
In order to pass the instance to the subsequent methods, the
Return the instance in each method.
```JS
class Class {
	constructor() {
		// variable initialize
	}

	fn1() {
		// processing content
		return this;
	}
	fn2() {
		// processing content
		return this;
	}
	fn3() {
		// processing content
		return this;
	}

}

const instance = new Class(args);

// access
instance.fn1()
	.fn2()
	.fn3();
```